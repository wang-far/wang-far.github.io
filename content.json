{"meta":{"title":"王向前的博客","subtitle":"我是测试副标题","description":"发布笔记。。。","author":"王向前的博客","url":"https://iquu.cc","root":"/"},"pages":[],"posts":[{"title":"","slug":"栈 队列 链表","date":"2021-07-04T07:13:20.579Z","updated":"2021-07-04T07:34:13.557Z","comments":true,"path":"2021/07/04/栈 队列 链表/","link":"","permalink":"https://iquu.cc/2021/07/04/%E6%A0%88%20%E9%98%9F%E5%88%97%20%E9%93%BE%E8%A1%A8/","excerpt":"","text":"栈、队列、链表第 1 节 解密 QQ 号——队列 其实解密的过程就像是将这些数“排队”。每次从最前面拿两个，第 1 个扔掉，第 2 个放到尾部 12345678910111213141516171819202122 #include &lt;stdio.h&gt; int main() &#123; int q[102]=&#123;0,6,3,1,7,5,8,9,2,4&#125;,head,tail; int i; //初始化队列 head=1; tail=10; //队列中已经有9个元素了，tail指向队尾的后一个位置 while(head&lt;tail) //当队列不为空的时候执行循环 &#123; //打印队首并将队首出队 printf(&quot;%d &quot;,q[head]); head++; //先将新队首的数添加到队尾 q[tail]=q[head]; tail++; 7//再将队首出队 head++; &#125; getchar();getchar(); return 0; &#125; 对常用方法体进行封装 封装式 123456789101112131415161718192021222324252627282930313233343536 #include &lt;stdio.h&gt; struct queue &#123; int data[100];//队列的主体，用来存储内容 int head;//队首 int tail;//队尾 &#125;; int main() &#123; struct queue q; int i; //初始化队列 q.head=1; q.tail=1; for(i=1;i&lt;=9;i++) &#123; //依次向队列插入9个数 scanf(&quot;%d&quot;,&amp;q.data[q.tail]); q.tail++; &#125; while(q.head&lt;q.tail) //当队列不为空的时候执行循环 &#123; //打印队首并将队首出队 printf(&quot;%d &quot;,q.data[q.head]); q.head++; //先将新队首的数添加到队尾 q.data[q.tail]=q.data[q.head]; q.tail++; //再将队首出队 q.head++; &#125; getchar();getchar(); return 0; &#125; 第 2 节 解密回文——栈 通过栈这个数据结构我们将很容易判断一个字符串是否为回文。 首先我们需要读取这行字符串，并求出这个字符串的长度 栈究竟有哪些作用呢？我们来看一个例子。“xyzyx”是一个回文字符串，所谓回文字符 串就是指正读反读均相同的字符序列，如“席主席”、“记书记”、“aha”和“ahaha”均是回 文，但“ahah”不是回文。通过栈这个数据结构我们将很容易判断一个字符串是否为回文。 首先我们需要读取这行字符串，并求出这个字符串的长度。 char a[101]; int len; gets(a); len=strlen(a); 如果一个字符串是回文的话，那么它必须是中间对称的，我们需要求中点，即： mid=len/2-1; 接下来就轮到栈出场了。 我们先将 mid 之前的字符全部入栈。因为这里的栈是用来存储字符的，所以这里用来实 现栈的数组类型是字符数组即 char s[101];，初始化栈很简单，top=0;就可以了。入栈的操作 是top++; s[top]=x; （假设需要入栈的字符暂存在字符变量x中），其实可以简写为s[++top]=x;。 现在我们就来将 mid 之前的字符依次全部入栈。 for(i=0;i&lt;=mid;i++) { s[++top]=a[i]; } 接下来进入判断回文的关键步骤。将当前栈中的字符依次出栈，看看是否能与 mid 之后 的字符一一匹配，如果都能匹配则说明这个字符串是回文字符串，否则这个字符串就不是回 文字符串。 12345678910111213for(i=mid+1;i&lt;=len-1;i++) &#123; if (a[i]!=s[top]) &#123; break; &#125; top--; &#125; if(top==0) printf(&quot;YES&quot;); else printf(&quot;NO&quot;); 最后如果 top 的值为 0，就说明栈内所有的字符都被一一匹配了，那么这个字符串就是 回文字符串。完整的代码如下 12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt; #include &lt;string.h&gt; int main() &#123; char a[101],s[101]; int i,len,mid,next,top; gets(a); //读入一行字符串 len=strlen(a); //求字符串的长度 mid=len/2-1; //求字符串的中点 top=0;//栈的初始化 //将mid前的字符依次入栈 for(i=0;i&lt;=mid;i++) s[++top]=a[i]; //判断字符串的长度是奇数还是偶数，并找出需要进行字符匹配的起始下标 if(len%2==0) next=mid+1; else next=mid+2; //开始匹配 for(i=next;i&lt;=len-1;i++) &#123; if(a[i]!=s[top]) break; top--; &#125; //如果top的值为0，则说明栈内所有的字符都被一一匹配了 if(top==0) printf(&quot;YES&quot;); else printf(&quot;NO&quot;); getchar();getchar(); return 0; &#125; 可以输入以下数据进行验证。 ahaha 运行结果是： YES 栈还可以用来进行验证括号的匹配。比如输入一行只包含“()[]{}”的字符串，请判断 形如“([{}()])”或者“{()[]{}}”的是否可以正确匹配。显然上面两个例子都是可以正确匹 配的。“([)]”是不能匹配的。有兴趣的同学可以自己动手来试一试。 堆栈最早由 Alan M. Turing（艾伦·图灵）于 1946 年提出，当时是为了解决子程序的调 用和返回。艾伦·图灵这个大帅哥可是个大牛人，图灵奖就是以他的名字命名的。如果你对 他感兴趣不妨去读一读《艾伦·图灵传：如谜的解谜者》和《图灵的秘密》。 第 3 节 纸牌游戏——小猫钓鱼123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127#include &lt;stdio.h&gt; struct queue &#123; int data[1000]; int head; int tail; &#125;; struct stack &#123; int data[10]; int top; &#125;; int main() &#123; struct queue q1,q2; struct stack s; int book[10]; int i,t; //初始化队列 q1.head=1; q1.tail=1; q2.head=1; q2.tail=1; //初始化栈 s.top=0; //初始化用来标记的数组，用来标记哪些牌已经在桌上 for(i=1;i&lt;=9;i++) book[i]=0; //依次向队列插入6个数 //小哼手上的6张牌 for(i=1;i&lt;=6;i++) &#123; scanf(&quot;%d&quot;,&amp;q1.data[q1.tail]); q1.tail++; &#125; //小哈手上的6张牌 for(i=1;i&lt;=6;i++) &#123; scanf(&quot;%d&quot;,&amp;q2.data[q2.tail]); q2.tail++; &#125; while(q1.head&lt;q1.tail &amp;&amp; q2.head&lt;q2.tail ) //当队列不为空的时候执行循环 &#123; t=q1.data[q1.head];//小哼出一张牌 //判断小哼当前打出的牌是否能赢牌 if(book[t]==0) //表明桌上没有牌面为t的牌 &#123; //小哼此轮没有赢牌 q1.head++; //小哼已经打出一张牌，所以要把打出的牌出队 s.top++; s.data[s.top]=t; //再把打出的牌放到桌上，即入栈 book[t]=1; //标记桌上现在已经有牌面为t的牌 &#125; else &#123; //小哼此轮可以赢牌 q1.head++;//小哼已经打出一张牌，所以要把打出的牌出队 q1.data[q1.tail]=t;//紧接着把打出的牌放到手中牌的末尾 q1.tail++; while(s.data[s.top]!=t) //把桌上可以赢得的牌依次放到手中牌的末尾 &#123; book[s.data[s.top]]=0;//取消标记 q1.data[q1.tail]=s.data[s.top];//依次放入队尾 q1.tail++; s.top--; //栈中少了一张牌，所以栈顶要减1 &#125; &#125; t=q2.data[q2.head]; //小哈出一张牌 //判断小哈当前打出的牌是否能赢牌 if(book[t]==0) //表明桌上没有牌面为t的牌 &#123; //小哈此轮没有赢牌 q2.head++; //小哈已经打出一张牌，所以要把打出的牌出队 s.top++; s.data[s.top]=t; //再把打出的牌放到桌上，即入栈 book[t]=1; //标记桌上现在已经有牌面为t的牌 &#125; else &#123; //小哈此轮可以赢牌 q2.head++;//小哈已经打出一张牌，所以要把打出的牌出队 q2.data[q2.tail]=t;//紧接着把打出的牌放到手中牌的末尾 q2.tail++; while(s.data[s.top]!=t) //把桌上可以赢得的牌依次放到手中牌的末尾 &#123; book[s.data[s.top]]=0;//取消标记第 2 章 栈、队列、链表 q2.data[q2.tail]=s.data[s.top];//依次放入队尾 q2.tail++; s.top--; &#125; &#125; &#125; if(q2.head==q2.tail) &#123; printf(&quot;小哼win\\n&quot;); printf(&quot;小哼当前手中的牌是&quot;); for(i=q1.head;i&lt;=q1.tail-1;i++) printf(&quot; %d&quot;,q1.data[i]); if(s.top&gt;0) //如果桌上有牌则依次输出桌上的牌 &#123; printf(&quot;\\n桌上的牌是&quot;); for(i=1;i&lt;=s.top;i++) printf(&quot; %d&quot;,s.data[i]); &#125; else printf(&quot;\\n桌上已经没有牌了&quot;); &#125; else &#123; printf(&quot;小哈win\\n&quot;); printf(&quot;小哈当前手中的牌是&quot;); for(i=q2.head;i&lt;=q2.tail-1;i++) printf(&quot; %d&quot;,q2.data[i]); if(s.top&gt;0) //如果桌上有牌则依次输出桌上的牌 &#123; printf(&quot;\\n桌上的牌是&quot;); for(i=1;i&lt;=s.top;i++) printf(&quot; %d&quot;,s.data[i]); &#125; else printf(&quot;\\n桌上已经没有牌了&quot;); &#125; getchar();getchar(); return 0; &#125; 第 4 节 链表指针有什么作用呢？答案是：存储一个地址。确切地说是存储一个内存空间的 地址，比如说整型变量 a 的地址。严格地说这里的指针 p 也只能存储“一个存放整数的内存 空间”的地址，因为在定义的时候我们已经限制了这一点（即定义的时候*p 的前面是 int）。 当然你也可以定义一个只能用来存储“一个存放浮点数的内存空间”的地址，例如： double *p; 简单地说，指针就是用来存储地址的。你可能要问：不就是存储地址嘛，地址不都一样 吗，为什么还要分不同类型的指针呢？不要着急，待会后面再解释。接下来需要解决的一个 问题：整型指针 p 如何才能存储整型变量 a 的地址呢？很简单，如下： p=&a; &amp;这个符号很熟悉吧，就是经常在 scanf 函数中用到的&amp;。&amp;叫取地址符。这样整型指针 p 就获得了（存储了）整型变量 a 的地址，我们可以形象地理解整型指针 p 指向了整型变量 a。p 指向了 a 之后，有什么用呢？用处就是我们可以用指针 p 来操作变量 a 了。比如我们可 以通过操作指针 p 来输出变量 a 的值，如下： 12345678910111213141516171819#include &lt;stdio.h&gt; int main() &#123; int a=10; int *p; //定义-个指针p p=&amp;a; //指针p获取变量a的地址 printf(&quot;%d&quot;,*p); //输出指针p所指向的内存中的值 getchar();getchar();return 0; &#125; 这里 printf 语句里面p 中的号叫做间接运算符，作用是取得指针 p 所指向的内存中的 值。在 C 语言中*号有三个用途，分别是： \\1. 乘号，用做乘法运算，例如 5*6。 \\2. 申明一个指针，在定义指针变量时使用，例如 int *p;。 \\3. 间接运算符，取得指针所指向的内存中的值，例如 printf(“%d”,*p);。 123456789101112131415161718192021#include &lt;stdio.h&gt; \\#include &lt;stdlib.h&gt; int main() &#123; int *p; //定义一个指针p p=(int *)malloc(sizeof(int)); //指针p获取动态分配的内存空间地址 *p=10; //向指针p所指向的内存空间中存入10 printf(&quot;%d&quot;,*p); //输出指针p所指向的内存中的值 getchar();getchar();return 0; &#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; //这里创建一个结构体用来表示链表的结点类型 struct node&#123; int data; struct node *next;&#125;;int main()&#123; struct node *head, *p, *q, *t; int i, n, a; scanf(&quot;%d&quot;,&amp;n); head = NULL;//头指针初始为空 for (i = 1; i &lt;= n; i++)//循环读入n个数 &#123; scanf(&quot;%d&quot;,&amp;a); //动态申请一个空间，用来存放一个结点，并用临时指针p指向这个结点 p = (struct node *)malloc(sizeof(struct node)); p-&gt;data = a;//将数据存储到当前结点的data域中 p-&gt;next = NULL;//设置当前结点的后继指针指向空，也就是当前结点的下一个结点为空 if (head == NULL) head = p;//如果这是第一个创建的结点，则将头指针指向这个结点 else q-&gt;next = p;//如果不是第一个创建的结点，则将上一个结点的后继指针指向当前结点 q = p;//指针q也指向当前结点 &#125; scanf(&quot;%d&quot;,&amp;a);//读入待插入的数 t = head;//从链表头部开始遍历 while (t != NULL)//当没有到达链表尾部的时候循环 &#123; if (t-&gt;next-&gt;data &gt; a)//如果当前结点下一个结点的值大于待插入数，将数插入到中间 &#123; p = (struct node *)malloc(sizeof(struct node));//动态申请一个空间， 用来存放新增结点 p-&gt;data = a; p-&gt;next = t-&gt;next;//新增结点的后继指针指向当前结点的后继指针所指向的结点 t-&gt;next = p;//当前结点的后继指针指向新增结点 break;//插入完毕退出循环 &#125; t = t-&gt;next;//继续下一个结点 &#125; //输出链表中的所有数 t = head; while (t != NULL) &#123; printf(&quot;%d &quot;, t-&gt;data); t = t-&gt;next;//继续下一个结点 &#125; getchar(); getchar(); return 0;&#125; 第 5 节 模拟链表例如 right[1] 的值为 2，就表示当前序列中 1 号元素右边的元素存放在 data[2]中；如果是 0，例如right[9] 的值为 0，就表示当前序列中9 号元素的右边没有元素 **data ** 里面放值 right 里面放其该值的下一个值的地址，这样就可以直接根据right里面的值去找数了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;stdio.h&gt; int main()&#123; int data[101], right[101]; int i, n, t, len; //读入已有的数 scanf(&quot;%d&quot;, &amp;n); for (i = 1; i &lt;= n; i++) scanf(&quot;%d&quot;, &amp;data[i]); len = n; //初始化数组right for (i = 1; i &lt;= n; i++) &#123; if (i != n) right[i] = i + 1; else right[i] = 0; &#125; //直接在数组data的末尾增加一个数 len++; scanf(&quot;%d&quot;, &amp;data[len]); //从链表的头部开始遍历 t = 1; while (t != 0) &#123; if (data[right[t]] &gt; data[len])//如果当前结点下一个结点的值大于待插入数，将数插入到中间 &#123; right[len] = right[t];//新插入数的下一个结点标号等于当前结点的下一个结点编号 right[t] = len;//当前结点的下一个结点编号就是新插入数的编号 break;//插入完成跳出循环 &#125; t = right[t]; &#125; //输出链表中所有的数 t = 1; while (t != 0) &#123; printf(&quot;%d &quot;, data[t]); t = right[t]; &#125; getchar(); getchar(); return 0;&#125;","categories":[],"tags":[]},{"title":"","slug":"排序算法","date":"2021-07-04T04:17:33.125Z","updated":"2021-07-04T07:20:33.812Z","comments":true,"path":"2021/07/04/排序算法/","link":"","permalink":"https://iquu.cc/2021/07/04/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","excerpt":"","text":"排序最快最简单的排序——桶排序对11个数进行排序申请一个大小为11的数组int a[11] 例：当 开始出现第一个分数 为5 时在a[5]的值 从0改为1 表示五分出现过一次 当第二次出现5时 a[5]加一 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;using namespace std;int main()&#123;int a[11], i, j, t;for (i = 0; i &lt;= 10; i++) &#123;a[i] = 0;//初始化为0&#125;for (i = 1; i &lt;= 5; i++) &#123;cin &gt;&gt; t;//进行计数 例如当出现5时在a[5]上加一a[t]++;&#125;for (i = 0; i &lt;= 10; i++) &#123;for (j = 1; j &lt;= a[i]; j++) //例如当输入2时 a[2] = 1 因为j= a[2]= 1 ; 然后打印一个2；cout &lt;&lt; &quot; &quot; &lt;&lt; i;&#125;return 0;&#125; 第 2 节 邻居好说话——冒泡排序 ​ 冒泡排序的基本思想是：每次比较两个相邻的元素，如果它们的顺序错误就把它们交换 过来。(进行比大小，从大到小排列时 两个数进行比较如果前一个数比后一个打则交换位置) 123456789101112131415161718192021222324#include&lt;iostream&gt;using namespace std;int main()&#123; int a[100], i, j, t, n; cin &gt;&gt; n; //输入一个数n，表示接下来有n个数 for (i = 1; i &lt;= n; i++) //循环读入n个数到数组a中 cin &gt;&gt; a[i]; //冒泡排序的核心部分 for (i = 1; i &lt;= n - 1; i++) //n个数排序，只用进行n-1趟 &#123; for (j = 1; j &lt;= n - i; j++) ////比较在剩余值里面的其余值&#123; if (a[j] &lt; a[j + 1]) //比较大小并交换 &#123; t = a[j]; a[j] = a[j + 1]; a[j + 1] = t; &#125; &#125; &#125; for (i = 1; i &lt;= n; i++) //输出结果 cout &lt;&lt; &quot; &quot;&lt;&lt; a[i]; return 0;&#125; 最常用的排序——快速排序​ 分别从初始序列“6 1 2 7 9 3 4 5 10 8”两端开始“探测”。先从 ​ 右往左找一个小于 6 的数，再从左往右找一个大于 6 的数，然后交换它们。这里可以用两个 变量 i 和 j，分别指向序列最左边和最右边。我们为这两个变量起个好听的名字“哨兵 i”和 “哨兵 j”。刚开始的时候让哨兵 i 指向序列的最左边（即 i=1），指向数字 6。让哨兵 j 指向序 列的最右边（即 j=10），指向数字 8。 首先在这个序列中随便找一个数作为基准数（不要被这个名词吓到了，这就是一个用来参照的数， ​ 因此快速排序的最差时间复杂度和冒泡排序是一样的，都是 O(N2)，它的平均时间复杂度为 O (NlogN)。其实快速排序是基于一 种叫做“二分”的思想。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;iostream&gt;using namespace std; int a[101], n;//定义全局变量，这两个变量需要在子函数中使用 void quicksort(int left, int right) &#123; int i, j, t, temp; if (left &gt; right) return; temp = a[left]; //temp中存的就是基准数 i = left; j = right; while (i != j) &#123; //顺序很重要，要先从右往左找 while (a[j] &gt;= temp &amp;&amp; i &lt; j) j--; //再从左往右找 while (a[i] &lt;= temp &amp;&amp; i &lt; j) i++; //交换两个数在数组中的位置 if (i &lt; j)//当哨兵i和哨兵j没有相遇时 &#123; t = a[i]; a[i] = a[j]; a[j] = t; &#125; &#125; //最终将基准数归位 a[left] = a[i]; a[i] = temp; quicksort(left, i - 1);//继续处理左边的，这里是一个递归的过程 quicksort(i + 1, right);//继续处理右边的，这里是一个递归的过程 &#125; int main() &#123; int i, j, t; //读入数据 cin &gt;&gt; n; for (i = 1; i &lt;= n; i++) cin &gt;&gt; a[i]; quicksort(1, n); //快速排序调用 //输出排序后的结果 for (i = 1; i &lt;= n; i++) cout &lt;&lt; &quot; &quot; &lt;&lt; a[i]; return 0;&#125; 小哼买书​ 第一种方法：先将这 n 个图书的 ISBN 号去重，再进 行从小到大排序并输出；第二种方法：先从小到大排序，输出的时候再去重。这两种方法都 可以。 先来看第一种方法。通过第一节的学习我们发现，桶排序稍加改动正好可以起到去重的 效果，因此我们可以使用桶排序的方法来解决此问题 1234567891011121314151617181920#include&lt;iostream&gt;using namespace std;int main() &#123; int a[1001], i, j, t; for (i = 1; i &lt;= 1000;i++) &#123; a[i] = 0; &#125; cin &gt;&gt; t; for (i = 1; i &lt;= t;i++ ) &#123; cin &gt;&gt; j; a[j] = 1; &#125; for (i = 1; i &lt; 1000; i++) &#123; if (a[i] == 1) &#123; cout &lt;&lt; &quot; &quot;&lt;&lt; i; &#125; &#125; return 0;&#125;","categories":[],"tags":[]},{"title":"test","slug":"test ","date":"2021-06-16T15:31:03.684Z","updated":"2021-06-16T15:31:29.052Z","comments":true,"path":"2021/06/16/test /","link":"","permalink":"https://iquu.cc/2021/06/16/test%20/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}